#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <opencv2/opencv.hpp>
#include <signal.h>
#include <unistd.h>

#include "map_text_synthesizer.hpp"

extern "C" {
#include "prod_cons.h"
};

// Necessary for signal handler
void* g_buff;

/* Write sample data into buff naively */
void write_data(intptr_t buff, uint32_t height,
		const char* label, uint64_t img_sz, unsigned char* img_flat) {

  /* Keep track of start to write to later */
  uint64_t* start_buff = (uint64_t*)buff;
  
  /* Skip past first 8 bytes (to write to-be-consumed magic num later */
  buff += sizeof(uint64_t);

  // 8 byte bc 4 byte wouldn't have the 8 byte alignment...
  *(uint64_t*)buff = height;
  buff += sizeof(uint64_t);

  // Write label into buff, and update buff
  strcpy((char*)buff, label);
  buff += (MAX_WORD_LENGTH + 1) * sizeof(char);

  // Write img_sz into buff, and update buff
  *(uint64_t*)buff = img_sz;
  buff += sizeof(uint64_t);

  // Write image into buff, and update buff
  memcpy((unsigned char*)buff, img_flat, img_sz);
  buff += img_sz * sizeof(unsigned char);

  // Mark as consumable
  *start_buff = SHOULD_CONSUME;
}

/* Create synthesizer and produce until signaled */
void produce(intptr_t buff, int semid, const char* config_file) {

  // Create mts according to config file
  cv::Ptr<MapTextSynthesizer> mts = MapTextSynthesizer::create(config_file);

  // Allocate some stack space for MTS data
  std::string label;
  cv::Mat image;
  int height;

  // Produce loop (terminates only by signal)
  while(1) {
    // Fill label, image, height with data from next synth sample
    mts->generateSample(label, image, height);

    // Ensure something was created
    if(image.data == NULL || label.c_str() == NULL) {
      fprintf(stderr, "Nothing generated by synthesizer.\n");
      exit(1);
    }

    // Calculate image size w/ 1 channel
    uint64_t image_size = image.rows * image.cols;
    
    /* Get & update the producer offset atomically */
    lock_buff(semid);

    // Save write loc
    intptr_t write_loc = buff + *((uint64_t*)buff);

    /* Calculate & update producer offset for future producers */
    
    // If there's no space to fit this image in the current buff
    if(((*(uint64_t*)buff) + BASE_CHUNK_SIZE + image_size) > SHM_SIZE) {

      // Write in magic number to tell consumer to reset consume offset
      if(((*(uint64_t*)buff) + sizeof(uint64_t)) > SHM_SIZE) {
	// Can't fit magic num, need consumer to know not enough space
      } else {
	*((uint64_t*)write_loc) = NO_SPACE_TO_PRODUCE;
      }
      // Reset offset
      *((uint64_t*)buff) = START_BUFF_OFFSET;
      write_loc = buff + *((uint64_t*)buff);
    }

    // Update producer offset
    *((uint64_t*)buff) += (BASE_CHUNK_SIZE + image_size);

    // Force 8 byte alignment
    *((uint64_t*)buff) += *((uint64_t*)buff) % 8;

    // Check out the consume_offset 
    uint64_t volatile consume_offset = *((uint64_t volatile*)(buff+sizeof(uint64_t)));
    
    /* Sleep until producer-consumer offsets have 
     * cleared memory corruption territory...
     * (checking if current producer offset is less than consume offset, and
     * that the producer offset is greater than the consume offset 
     * (ie a write that would corrupt memory)
     */
    while(write_loc - buff < consume_offset
	  && *((uint64_t*)buff) >= consume_offset) {
      sleep(5); // 5 is arbitrary
      
      // Update consume offset
      consume_offset = *((uint64_t volatile*)(buff+sizeof(uint64_t)));
    }

    /* Verify no bad overwritage would occur */
    uint64_t needle = SHOULD_CONSUME;
    while(memmem((void*)write_loc, (*((uint64_t*)buff)+buff) - write_loc,
	       (void*)&needle, sizeof(uint64_t))) {
      sleep(5); // 5 is arbitrary
    }
    
    unlock_buff(semid);

    /* Write data into buff */
    write_data(write_loc, height, label.c_str(),
	       image_size, image.data);
  }
}

/* Signal handler */
void cleanup(int signo) {
  /* detach from segment */
  if(shmdt(g_buff) == -1) {
    perror("shmdt");
  }
  exit(1);
}

/* main */
int main(int argc, char *argv[]) {
  if(argc != 2) {
    fprintf(stderr,"usage: producer \"/path/to/config_file\"");
    exit(1);
  }
  
  struct sigaction sa;
  sa.sa_handler = cleanup;
  sigaction(SIGHUP, NULL, &sa);
  
  g_buff = get_shared_buff(0);
  int semid = get_semaphores(0);
  
  produce((intptr_t)g_buff, semid, argv[1]);
  
  /* detach from segment (NOTE: program ex really shouldn't reach this...) */
  if(shmdt(g_buff) == -1) {
    perror("shmdt");
    exit(1);
  }
  
  return 0;
}

